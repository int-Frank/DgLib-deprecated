//================================================================================
// @ CommonMath.cpp
// 
// Description: 
//
// This files contains some useful math constant definitions.
//
// -------------------------------------------------------------------------------
//
// Author: Frank Hart
// Date last modified: 2013
//
//================================================================================

#include "dgmath.h"

namespace Dg
{
  const float PI_f            = 3.141592653589793238462643383279f;
  const float TWOPI_f         = 6.283185307179586476925286766559f;
  const float HALFPI_f        = 1.570796326794896619231321691639f;
  const float INVPI_f         = 0.31830988618379067153776752674503f;
  const float EPSILON_f       = 1.0e-4f;
  const float SQRT2_f         = 1.4142135623730950488016887242097f;

  const double PI_d           = 3.141592653589793238462643383279;
  const double TWOPI_d        = 6.283185307179586476925286766559;
  const double HALFPI_d       = 1.570796326794896619231321691639;
  const double INVPI_d        = 0.31830988618379067153776752674503;
  const double INV_SQRT_2PI_d = 0.39894228040143267793994605993438;
  const double EPSILON_d      = static_cast<double>(EPSILON_f);
  const double SQRT2_d        = 1.4142135623730950488016887242097;

  namespace impl
  {
    static uint32_t const TAB32[32] = {
      0, 9, 1, 10, 13, 21, 2, 29,
      11, 14, 16, 18, 22, 25, 3, 30,
      8, 12, 20, 28, 15, 17, 24, 7,
      19, 27, 23, 6, 26, 5, 4, 31 };

    static double const s_denominators[] = 
    { 
      0.3989422804014327, -2.3936536824085963, 15.957691216057308, -134.04460621488138,
      1378.7445210673513, -16851.321924156517, 238982.38365167426, -3860484.6589885838,
      70003455.149659663, -1408304803.5990355, 31130948290.083942, -750107611180.1178,
      19568024639481.336, -549470131876635.87, 16524805447549198, -529933416076577730,
      18051925399253744000, -6.50963370457938e+020, 2.4773805984284955e+022, -9.9229136401919748e+023,
      4.1727124025422663e+025, -1.8380289265832518e+027, 8.4634820340345092e+028, -4.0662329239072462e+030,
      2.0348467738361368e+032, -1.0589508720983976e+034, 5.722487457849381e+035, -3.20675240562503e+037,
      1.8610824870463811e+039, -1.1173025036267923e+041, 6.9310629886001006e+042, -4.4381527923724583e+044,
      2.9305897803602264e+046, -1.9937027705773724e+048, 1.396187074559557e+050, -1.0056593855885504e+052,
      7.4447122966949591e+053, -5.660020992692743e+055, 4.4163257132317241e+057, -3.5342076681732319e+059,
      2.8989450240205749e+061, -2.4358296090721028e+063, 2.0954004106957607e+065, -1.8444453968030216e+067,
      1.6604248675587659e+069, -1.5279640073377858e+071, 1.4366219831628673e+073, -1.3794660548004739e+075,
      1.3521671476107382e+077, -1.3524459449607612e+079, 1.3797680852629987e+081, -1.435232030076541e+083,
      1.5216246377122162e+085, -1.6436444419935197e+087, 1.8083161094530575e+089, -2.025645843708425e+091,
      2.3096012430607052e+093, -2.6795462209314912e+095, 3.1623305487375823e+097, -3.7953372278096693e+099,
      4.6309492897307905e+101, -5.7431425654297706e+103, 7.2372934767610929e+105, -9.2648936172104804e+107,
      1.2045820740738538e+110, -1.5902350946881964e+112, 2.1311578108661048e+114, -2.8986950976366794e+116,
      4.0006286710493789e+118, -5.6014641728517651e+120, 7.9548850915175419e+122, -1.1456162884280511e+125,
      1.6727600071592802e+127, -2.475915536113963e+129, 3.7142101634275594e+131, -5.6460980001096791e+133,
      8.6957387477185894e+135, -1.3566489144316516e+138, 2.1436803362748394e+140, -3.4301616183373578e+142,
      5.5572932885767498e+144, -9.1146513402582397e+146, 1.5131439586956318e+149, -2.5422652619975943e+151,
      4.3221554083015384e+153, -7.4346187999601018e+155, 1.2937106257989053e+158, -2.277080263328131e+160,
      4.0534631064684535e+162, -7.2966916100733247e+164, 1.3280794003139045e+167, -2.4438128456825915e+169,
      4.5457589763407326e+171, -8.5465183089234256e+173, 1.6239298853083803e+176, -3.1181172242243977e+178,
      6.0494739194167178e+180, -1.1857595770545826e+183, 2.3479255789349506e+185, -4.6960895259489808e+187,
      9.4865728112135214e+189, -1.9353552472468736e+192, 3.9870224847223766e+194, -8.2933957460259324e+196,
      1.7416932360929434e+199, -3.6925563297262357e+201, 7.9024205509534553e+203, -1.7069970401378802e+206,
      3.721412337922917e+208, -8.1874501307426695e+210, 1.8176887002589431e+213, -4.071787185294988e+215,
      9.2026042214738737e+217, -2.0982755634224563e+220, 4.8262186659653437e+222, -1.1197248808853219e+225,
      2.6202531671487862e+227, -6.184022388906084e+229, 1.4718499585374259e+232, -3.5325641072373782e+234,
      8.5491007515736383e+236, -2.0860515302781713e+239, 5.1318584559682764e+241, -1.2727427898022221e+244,
      3.1819600306018954e+246, -8.0187948562356999e+248, 2.0368377882635985e+251, -5.2144657527997345e+253,
      1.3453730619929418e+256, -3.4980746594744107e+258, 9.1652257294182822e+260, -2.4196898241812113e+263,
      6.436558939152758e+265, -1.7250463734962536e+268, 4.6577544253967009e+270, -1.2669438338523293e+273,
      3.4715196061453346e+275, -9.5816484367417937e+277, 2.6637679501301222e+280, -7.4587425901802362e+282,
      2.1034188781196452e+285, -5.973859323388483e+287, 1.7085659845761971e+290, -4.9207899349467858e+292,
      1.4270633723536269e+295, -4.1671238059834797e+297, 1.225163038985301e+300, -3.6265662242728718e+302,
      1.0807413217229719e+305, -3.2422967423622981e+307 
    };

    double const s_standardDeviations[] = {
      0.34134474606854298, 0.4772498680518209,
      0.4986501019683704, 0.49996832875816521,
      0.49999971334886473, 0.49999999895174302 };
  }
  
  
  //--------------------------------------------------------------------------------
  //	@	Log2()
  //--------------------------------------------------------------------------------
  uint32_t Log2(uint32_t input)
  {
  	input |= (input >> 1);
  	input |= (input >> 2);
  	input |= (input >> 4);
  	input |= (input >> 8);
  	input |= (input >> 16);
  	return impl::TAB32[(input * 0x07C4ACDD) >> 27];
  
  }	//End: Log2()
  
  
  //--------------------------------------------------------------------------------
  //	@	FloorPower2()
  //--------------------------------------------------------------------------------
  uint32_t FloorPower2(uint32_t input)
  {
  	input |= (input >> 1);
  	input |= (input >> 2);
  	input |= (input >> 4);
  	input |= (input >> 8);
  	input |= (input >> 16);
  	input -= (input >> 1);
  	return input;
  
  }	//End: FloorPower2()
  

  //--------------------------------------------------------------------------------
  //	@	IntegrateND()
  //--------------------------------------------------------------------------------
  double IntegrateND(double a_x)
  {
    double prevResult = a_x;
    double curResult;
    double x2 = a_x * a_x;
    double x = a_x;

    unsigned nDenom = sizeof(impl::s_denominators) / sizeof(*impl::s_denominators);

    for (unsigned k = 1; k < nDenom; ++k)
    {
      //Add next term in the Taylor expansion
      x *= x2;
      curResult = prevResult + x / impl::s_denominators[k];

      //Check to see if accuracy has been reached
      if (curResult == prevResult)
        break;

      //Assign the new value for the integral
      prevResult = curResult;
    }

    return curResult + 0.5;

  }	//End: IntegrateND()


  //--------------------------------------------------------------------------------
  //	@	SolveIntegralND()
  //--------------------------------------------------------------------------------
  Dg_Result SolveIntegralND(double a_intgX, double& a_out)
  {
    unsigned nSD = sizeof(impl::s_standardDeviations) / sizeof(*impl::s_standardDeviations);

    if ( a_intgX < 0.5 - impl::s_standardDeviations[nSD - 1]
      || a_intgX > 0.5 + impl::s_standardDeviations[nSD - 1])
    {
      return DgR_OutOfBounds;
    }

    double curX = 0.0;
    double prevX = -1.0;
    double step = static_cast<double>(nSD / 2);

    while (true)
    {
      //double integral = IntegrateND(curX);
      double integral = 0.5 * (1.0 + erf(curX / SQRT2_d));

      if (integral == a_intgX || curX == prevX)
      {
        a_out = curX;
        return DgR_Success;
      }

      prevX = curX;
      step *= 0.5;

      if (integral < a_intgX)
      {
        curX += step;
      }
      else
      {
        curX -= step;
      }
    }
  }	//End: SolveIntegralND()
}
